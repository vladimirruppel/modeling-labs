import numpy as np
from typing import Tuple, List


def get_variant_18_problem() -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """
    Получить задачу линейного программирования для варианта 18

    Задача: минимизация затрат на производство и закупку мангалов
    4 переменные: x1, x2, x3, x4
    - x1: угольные мангалы (производство)
    - x2: газовые мангалы (производство)
    - x3: угольные мангалы (закупка)
    - x4: газовые мангалы (закупка)

    Returns:
        (c, A_ub, b_ub, A_eq, b_eq)
    """
    # Целевая функция: F = 4000*x1 + 8500*x2 + 5000*x3 + 10000*x4 -> min
    c = np.array([4000, 8500, 5000, 10000], dtype=float)

    # Все ограничения преобразованы в форму Ax <= b
    # Исходные ограничения >= преобразованы в ≤ путём умножения на -1

    A_ub = np.array([
        # Производство: 0.10*x1 + 0.20*x2 <= 2500
        [0.10, 0.20, 0, 0],
        # Сборка: 0.15*x1 + 0.25*x2 <= 4000
        [0.15, 0.25, 0, 0],
        # Упаковка: 0.05*x1 + 0.05*x2 <= 2000
        [0.05, 0.05, 0, 0],
        # Макс угольные производство: x1 <= 20000
        [1, 0, 0, 0],
        # Макс газовые производство: x2 <= 10000
        [0, 1, 0, 0],
        # Спрос на угольные (x1 + x3 >= 20000) -> (-x1 - x3 <= -20000)
        [-1, 0, -1, 0],
        # Спрос на газовые (x2 + x4 >= 10000) -> (-x2 - x4 <= -10000)
        [0, -1, 0, -1],
    ], dtype=float)

    b_ub = np.array([
        2500,      # производство
        4000,      # сборка
        2000,      # упаковка
        20000,     # макс угольные
        10000,     # макс газовые
        -20000,    # спрос угольные (отрицательный)
        -10000,    # спрос газовые (отрицательный)
    ], dtype=float)

    # Нет ограничений =
    A_eq = None
    b_eq = None

    return c, A_ub, b_ub, A_eq, b_eq


def get_variable_names() -> List[str]:
    """Получить имена переменных"""
    return ['x₁ (угольные прив.)',
            'x₂ (газовые прив.)',
            'x₃ (угольные закупка)',
            'x₄ (газовые закупка)']


def get_constraint_names() -> List[str]:
    """Получить имена ограничений"""
    return [
        'цех производства',
        'цех сборки',
        'цех упаковки',
        'макс. угольные (прив.)',
        'макс. газовые (прив.)',
        'спрос угольные',
        'спрос газовые'
    ]


def print_problem_statement():
    """Вывести постановку задачи"""
    print("\n" + "="*70)
    print("ЗАДАЧА ЛИНЕЙНОГО ПРОГРАММИРОВАНИЯ (ВАРИАНТ 18)")
    print("="*70)

    print("\nЗЦЕЛЬ: Минимизировать затраты на производство и закупку мангалов")

    print("\nПЕРЕМЕННЫЕ:")
    print("  x₁ = количество угольных мангалов, производимых собственно (шт/месяц)")
    print("  x₂ = количество газовых мангалов, производимых собственно (шт/месяц)")
    print("  x₃ = количество угольных мангалов, закупаемых у других (шт/месяц)")
    print("  x₄ = количество газовых мангалов, закупаемых у других (шт/месяц)")

    print("\nЦЕЛЕВАЯ ФУНКЦИЯ:")
    print("  F = 4000·x₁ + 8500·x₂ + 5000·x₃ + 10000·x₄ → min (рубли)")

    print("\nОГРАНИЧЕНИЯ:")
    print("\n  1. СПРОС (контрактные обязательства):")
    print("     x₁ + x₃ ≥ 20000  (угольные мангалы)")
    print("     x₂ + x₄ ≥ 10000  (газовые мангалы)")

    print("\n  2. ПРОИЗВОДСТВЕННАЯ МОЩНОСТЬ (чел-ч/месяц):")
    print("     0.10·x₁ + 0.20·x₂ ≤ 2500  (цех производства)")
    print("     0.15·x₁ + 0.25·x₂ ≤ 4000  (цех сборки)")
    print("     0.05·x₁ + 0.05·x₂ ≤ 2000  (цех упаковки)")

    print("\n  3. МАКСИМАЛЬНОЕ СОБСТВЕННОЕ ПРОИЗВОДСТВО:")
    print("     x₁ ≤ 20000  (угольные)")
    print("     x₂ ≤ 10000  (газовые)")

    print("\n  4. УСЛОВИЕ НЕОТРИЦАТЕЛЬНОСТИ:")
    print("     x₁, x₂, x₃, x₄ ≥ 0")


def print_solution_analysis(x_optimal: np.ndarray, objective_value: float):
    """Вывести анализ оптимального решения"""
    print("\n" + "="*70)
    print("АНАЛИЗ ОПТИМАЛЬНОГО РЕШЕНИЯ")
    print("="*70)

    print("\nОПТИМАЛЬНЫЕ ЗНАЧЕНИЯ ПЕРЕМЕННЫХ:")
    print(f"  x₁ (угольные производство) = {x_optimal[0]:,.0f} шт/месяц")
    print(f"  x₂ (газовые производство) = {x_optimal[1]:,.0f} шт/месяц")
    print(f"  x₃ (угольные закупка) = {x_optimal[2]:,.0f} шт/месяц")
    print(f"  x₄ (газовые закупка) = {x_optimal[3]:,.0f} шт/месяц")

    print(f"\nМИНИМАЛЬНЫЕ ЗАТРАТЫ: {objective_value:,.0f} рублей ({objective_value/1e6:.2f} млн руб)")

    # Анализ использования ресурсов
    print("\nИСПОЛЬЗОВАНИЕ ПРОИЗВОДСТВЕННЫХ РЕСУРСОВ:")

    prod_used = 0.10 * x_optimal[0] + 0.20 * x_optimal[1]
    print(f"  Цех производства: {prod_used:.0f} / 2500 чел-ч ({prod_used/2500*100:.1f}%)")

    assm_used = 0.15 * x_optimal[0] + 0.25 * x_optimal[1]
    print(f"  Цех сборки: {assm_used:.0f} / 4000 чел-ч ({assm_used/4000*100:.1f}%)")

    pack_used = 0.05 * x_optimal[0] + 0.05 * x_optimal[1]
    print(f"  Цех упаковки: {pack_used:.0f} / 2000 чел-ч ({pack_used/2000*100:.1f}%)")

    # Проверка спроса
    print("\nУДОВЛЕТВОРЕНИЕ СПРОСА:")
    total_coal = x_optimal[0] + x_optimal[2]
    total_gas = x_optimal[1] + x_optimal[3]
    print(f"  Угольные мангалы: {total_coal:,.0f} шт (требуется 20000)")
    print(f"  Газовые мангалы: {total_gas:,.0f} шт (требуется 10000)")

    # Анализ затрат
    print("\nСТРУКТУРА ЗАТРАТ:")
    cost_x1 = 4000 * x_optimal[0]
    cost_x2 = 8500 * x_optimal[1]
    cost_x3 = 5000 * x_optimal[2]
    cost_x4 = 10000 * x_optimal[3]

    print(f"  Угольные (производство): 4000 × {x_optimal[0]:,.0f} = {cost_x1:,.0f} руб")
    print(f"  Газовые (производство): 8500 × {x_optimal[1]:,.0f} = {cost_x2:,.0f} руб")
    print(f"  Угольные (закупка): 5000 × {x_optimal[2]:,.0f} = {cost_x3:,.0f} руб")
    print(f"  Газовые (закупка): 10000 × {x_optimal[3]:,.0f} = {cost_x4:,.0f} руб")
    print(f"  {'─'*50}")
    print(f"  ИТОГО: {cost_x1 + cost_x2 + cost_x3 + cost_x4:,.0f} руб")


def verify_solution(x_optimal: np.ndarray, c, A_ub, b_ub) -> bool:
    """
    Проверить, что решение удовлетворяет ограничениям

    Returns:
        True если решение допустимо, False иначе
    """
    print("\n" + "="*70)
    print("ПРОВЕРКА ДОПУСТИМОСТИ РЕШЕНИЯ")
    print("="*70)

    constraint_names = get_constraint_names()

    # Проверить ≤ ограничения
    print("\nПроверка ограничений (≤):")
    all_valid = True

    for i in range(len(b_ub)):
        lhs = np.dot(A_ub[i], x_optimal)
        rhs = b_ub[i]
        satisfied = lhs <= rhs + 1e-6

        status = "✓" if satisfied else "✗"
        print(f"  {status} {constraint_names[i]}: {lhs:.2f} ≤ {rhs:.2f} ({satisfied})")

        if not satisfied:
            all_valid = False

    # Проверить неотрицательность
    print("\nПроверка неотрицательности:")
    var_names = get_variable_names()

    for i in range(len(x_optimal)):
        satisfied = x_optimal[i] >= -1e-6
        status = "✓" if satisfied else "✗"
        print(f"  {status} {var_names[i]}: {x_optimal[i]:.4f} ≥ 0 ({satisfied})")

        if not satisfied:
            all_valid = False

    if all_valid:
        print("\n✓ Решение допустимо!")
    else:
        print("\n✗ Решение не допустимо!")

    return all_valid
